import numpy as np
import statsmodels.api as sm
from scipy.stats import t, f


x = np.array([-2, 0, 1, 2, 4], dtype=float)
y = np.array([18, 3, 1, 3, 21], dtype=float)

# Строим матрицу для уравнения регрессии вида y = a0*x^2 + a1*x + a2
"""
[[ 4. -2.  1.]
 [ 0.  0.  1.]
 [ 1.  1.  1.]
 [ 4.  2.  1.]
 [16.  4.  1.]]
"""
X = np.column_stack([
    x**2,   # столбец для a0
    x,      # столбец для a1
    np.ones_like(x)  # столбец для a2 (свободный член)
])

n = len(y)
m = X.shape[1]  # число коэффициентов

# Находим произведение транспонированной матрицы F^T на исходную
XtX = X.T @ X

# Найдём произведение транспонированной матрицы F^T на вектор Y
Xty = X.T @ y

# Решаем систему нормальных уравнений (F^T F) a = F^T y
a = np.linalg.solve(XtX, Xty)

# Полученные оценки коэффициентов регрессии:
print("Полученные оценки коэффициентов регрессии:", a)

# model = sm.OLS(y, X)
# results = model.fit()
#
# print("/n")
# print(results.summary())


# Считаем вектор предсказанных значений ŷ = Xa
"""
    [ a0 ]
a = [ a1 ]
    [ a2 ]
"""
y_hat = X @ a

# Общая и остаточная сумма квадратов отклонений
SST = np.sum((y - np.mean(y))**2)
SSE = np.sum((y - y_hat)**2)

print("\nОбщая сумма квадратов =", SST)
print("Остаточня сумма квадратов отклонений =", SSE)

# Дисперсии
sigma_tilde2 = SST / (n - 1)     # общая дисперсия
sigma_res2 = SSE / (n - m)     # остаточная дисперсия

print("\nОбщая дисперсия =", sigma_tilde2)
print("Остаточная дисперсия =", sigma_res2)

# F-критерий
F_emp = sigma_tilde2 / sigma_res2
# Критическое значение F из таблицы распределения Фишера при α = 0.01
F_crit = 99.25
#F_crit = f.ppf(1 - 0.01, n - 1, n - m)   # F(α, f1=n-1, f2=n-m)

print("\nНаблюдаемое F =", F_emp)
print("Критическое F =", F_crit)

if F_emp > F_crit:
    print("→ Гипотеза об адекватности уравнения регрессии экспериментальным данным принимается")
else:
    print("→ Гипотеза об адекватности уравнения регрессии экспериментальным данным отвергается")

# t-критерий для коэффициентов

# Остаточная дисперсия
s2 = sigma_res2
# Вычисляем обратную матрицу через метод numpy.linalg.inv
# и умножаем ее на s2
cov = np.linalg.inv(XtX) * s2
# Берем диагональ корреляционной матрицы
# и извлекаем квадратный корень
stderr = np.sqrt(np.diag(cov))

# Считаем t
t_emp = a / stderr
# Критическое значение t из таблицы распределения Стьюдента при α = 0.01
t_crit = 9.92
#t_crit = t.ppf(1 - 0.01/2, n - m)   # двусторонний критерий

print("\nНаблюдаемые t:", t_emp)
print("Критические t:", t_crit)

for i, ti in enumerate(t_emp):
    if abs(ti) > t_crit:
        print(f"Коэффициент a{i} – значим")
    else:
        print(f"Коэффициент a{i} – не значим")