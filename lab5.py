import numpy as np

x1 = np.array([-3, 2, 0, 1, 2, -2], dtype=float)
x2 = np.array([-2.5, -1.5, -0.5, 0.5, 1.5, 2.5], dtype=float)
y = np.array([-17, -1, -4.5, 2, 8.3, -1], dtype=float)

# Строим матрицу для уравнения регрессии вида y = b0 + b1*x1 + b2*x2
"""
[[ 1.  -3.  -2.5]
 [ 1.   2.  -1.5]
 [ 1.   0.  -0.5]
 [ 1.   1.   0.5]
 [ 1.   2.   1.5]
 [ 1.  -2.   2.5]]
"""
X = np.column_stack([
    np.ones_like(x1), # столбец для a2 (свободный член)
    x1,   # столбец для a0
    x2      # столбец для a1
])

n = len(y)
m = X.shape[1]  # число коэффициентов

# Находим произведение транспонированной матрицы F^T на исходную
XtX = X.T @ X

# Найдём произведение транспонированной матрицы F^T на вектор Y
Xty = X.T @ y

# Решаем систему нормальных уравнений (F^T F) a = F^T y
b = np.linalg.solve(XtX, Xty)

# Полученные оценки коэффициентов регрессии:
print("Полученные оценки коэффициентов регрессии:", np.round(b, 3))

# model = sm.OLS(y, X)
# results = model.fit()
#
# print("/n")
# print(results.summary())


# Считаем вектор предсказанных значений ŷ = Xa
"""
    [ b0 ]
b = [ b1 ]
    [ b2 ]
"""
y_hat = X @ b

# Общая и остаточная сумма квадратов отклонений
SST = np.sum((y - np.mean(y))**2)
SSE = np.sum((y - y_hat)**2)

print("\nОбщая сумма квадратов =", SST)
print("Остаточня сумма квадратов отклонений =", SSE)

# Дисперсии
sigma_tilde2 = SST / (n - 1)     # общая дисперсия
sigma_res2 = SSE / (n - m)     # остаточная дисперсия

print("\nОбщая дисперсия =", sigma_tilde2)
print("Остаточная дисперсия =", sigma_res2)

# F-критерий
F_emp = sigma_tilde2 / sigma_res2
# Критическое значение F из таблицы распределения Фишера при α = 0.01
F_crit = 9.01
#F_crit = f.ppf(1 - 0.01, n - 1, n - m)   # F(α, f1=n-1, f2=n-m)

print("\nНаблюдаемое F =", F_emp)
print("Критическое F =", F_crit)

if F_emp > F_crit:
    print("→ Гипотеза об адекватности уравнения регрессии экспериментальным данным принимается")
else:
    print("→ Гипотеза об адекватности уравнения регрессии экспериментальным данным отвергается")

# t-критерий для коэффициентов

# Остаточная дисперсия
s2 = sigma_res2
# Вычисляем обратную матрицу через метод numpy.linalg.inv
# и умножаем ее на s2
cov = np.linalg.inv(XtX) * s2
# Берем диагональ корреляционной матрицы
# и извлекаем квадратный корень
stderr = np.sqrt(np.diag(cov))

# Считаем t
t_emp = b / stderr
# Критическое значение t из таблицы распределения Стьюдента при α = 0.01
t_crit = 3.18
#t_crit = t.ppf(1 - 0.01/2, n - m)   # двусторонний критерий

print("\nНаблюдаемые t:", t_emp)
print("Критические t:", t_crit)

for i, ti in enumerate(t_emp):
    if abs(ti) > t_crit:
        print(f"Коэффициент b{i} – значим")
    else:
        print(f"Коэффициент b{i} – не значим")